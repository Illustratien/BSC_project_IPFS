{
  "hash": "933495d53d6c300476439a2b826e47b8",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Week7: Shape of dataframe\"\nauthor: \"Tien-Cheng\"\ncategories: [R-intermediate]\n\ntoc-location: right\n# number-sections: true\nwebsite: \n  sidebar:\n    search: true\nformat:\n  html: \n    grid:\n      sidebar-width: 300px\n      body-width: 1200px\n      margin-width: 100px\n      gutter-width: 1.5rem\n\nreference-location: margin\n---\n\n\n\n\nWelcome to the seventh course! You will learn more about `dataframe` wrangling:\n\n::: callout-note\n# Learning goals\n\n1.  data frame wrangling with `dplyr` and `tidyr`\n2.  `ggplot()`\n:::\n\n::: callout-warning\n## Discussion\n\n9.  What is `case_when()`? How to write the syntax?\n10. When to use `match()` and `order()`?\n:::\n\n## Logic of coding\n\n![](coding_logic.png)\n\n1.  Check: examine the datatype of each column in your dataframe.\n\n2.  Drafting: draw the draft of your desired output.\n\n3.  Target columns: identify which columns you would need to generate the output.\n\n4.  Steps: write down the possible steps which required to generate the target columns.\n\n::: callout-warning\n## challenge\n\nHere is a draft from coding logic step2. Please practice step 1, 3 & 4 with `climate.csv`. Finally, can you reproduce this figure?\n\n\n::: {.cell}\n::: {.cell-output-display}\n![step2: Draft of target](index_files/figure-html/fig-ACC-1.png){#fig-ACC width=672}\n:::\n:::\n\n:::\n\n::: {.callout-note collapse=\"true\"}\n## answer for steps\n\n1.  check the datatype of `DayTime`, make sure it is `Date`.\n2.  `group_by`year and sowing date, `mutate` a new column called `DAS`(Days after sowing).\n3.  use `ggplot` to visualize this dataframe with points and lines:\n\nx is `DAS`, y is `Acc_Temperature`, color is `DFG_year` and the points should be linked of same `DFG_year` and `sowing_date`.\n\nIs there additional columns required?\n:::\n\n::: {.callout-note collapse=\"true\"}\n## answer for code\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclimate %>% \n  # dplyr::filter(DFG_year%in%c(\"DFG2019\",\"DFG2020\")) %>% \n  group_by(DFG_year,sowing_date) %>% \n  mutate(DayTime=as.Date(DayTime,format=\"%Y-%m-%d\"),\n         DAS=as.numeric(DayTime-min(DayTime))) %>% \n  ggplot(aes(x=DAS,y=Acc_Temperature,color=DFG_year,\n             group=interaction(sowing_date,DFG_year)))+\n  # geom_point()+\n  geom_line(aes(linetype=sowing_date),linewidth=1)+\n  theme_bw()+\n  theme(legend.position = c(.1,.65))+\n  labs(x=\"Days after sowing\",y= \"Thermal sum (°Cd)\")+\n  guides(color=guide_legend(title=\"Year\"))\n```\n:::\n\n:::\n\n### how to get the minimum unique combination of dataframe?\n\nhow many unique year-months combinations were included in \\`climate 2019 for early and late sowing?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclimate %>% \n  dplyr::filter(DFG_year==\"DFG2019\") %>% \n  group_by(y,m) %>% \n  summarise()\n\nclimate %>% \n  dplyr::filter(DFG_year==\"DFG2019\") %>% \n  dplyr::select(y,m) %>% \n  dplyr::distinct()\n```\n:::\n\n\n::: callout-warning\n## challenge\n\nread `ear_summarized.csv` and extract the unique combinations of nitrogen, appl and timeid\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\n  nitrogen     appl timeid\n1      176 Combined  Early\n2      176 Combined   Late\n3      176    Split  Early\n4      176    Split   Late\n5      220 Combined  Early\n6      220 Combined   Late\n7      220    Split  Early\n8      220    Split   Late\n```\n\n\n:::\n:::\n\n:::\n\n## Shapes of dataframe.\n\n![](wide_long.png)\n\nIn general, we can describe the shape of dataframe as wide or long.[^1]\n\n[^1]: [tidyr cheatsheet](https://tidyr.tidyverse.org) [tidyr example](https://tidyr.tidyverse.org/articles/tidy-data.html)\n\n-   Wide refers to a dataframe which each column is one trait.\n\n-   Long refers to a dataframe which multiple trait names in one column and multiple trait values in another one.\n\n### Relationship of shape of dataframe and data processing\n\n`mutate()` is designed for column-wise calculation.\n\nwide format:\n\n-   `across()` provide quick access to multiple columns, could be useful for wide format.\n\nlong format:\n\n-   Since the values are concentrated in one column, this format is suitable for unifying operation.\n-   `facet_grid()` will required a column which stores the grouping information for facet. This is can be achieved via the long format.\n\n### wide to long\n\nIn the following examples, we want a unifying change\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# climate %>%glimpse()\nclimate_long <- climate %>% \n  tidyr::pivot_longer(names_to = \"Daily_Terms\",\n                      values_to = \"Daily_value\",\n                      cols = contains(\"Daily\")) \n# climate_long%>%   names()\n\n#select cols by position\n# grep(\"(Daily|Acc)\",names(climate))\nclimate_long <- climate %>% \n  tidyr::pivot_longer(names_to = \"Terms\",\n                      values_to = \"value\",\n                      # select both patterns\n                      cols = grep(\"(Daily|Acc)\",names(.)))\n\n# climate_long%>% names()\n\n## data processing example\nclimate_long_subset<- climate_long %>% \n  filter(Terms%in%c('Acc_Temperature','Acc_Precipitation')) %>% \n  group_by(DFG_year,sowing_date,Terms) %>%\n  summarise(Value=mean(value))\n\nclimate_long_subset\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 6 × 4\n# Groups:   DFG_year, sowing_date [6]\n  DFG_year sowing_date Terms           Value\n  <chr>    <chr>       <chr>           <dbl>\n1 DFG2019  Early       Acc_Temperature  923.\n2 DFG2019  Late        Acc_Temperature  856.\n3 DFG2020  Early       Acc_Temperature 1002.\n4 DFG2020  Late        Acc_Temperature  910.\n5 DFG2021  Early       Acc_Temperature  928.\n6 DFG2021  Late        Acc_Temperature  799.\n```\n\n\n:::\n\n```{.r .cell-code}\n#Fig 2\nlibrary(scales) %>% suppressMessages()\n\nclimate_long %>% \n  filter(Terms%in%c('Acc_Temperature','Acc_Radiation'),\n         sowing_date=='Early') %>% \n  group_by(DFG_year,sowing_date) %>% \n  mutate(DayTime=as.Date(DayTime,format=\"%Y-%m-%d\"),\n         DAS=as.numeric(DayTime-min(DayTime))) %>% \n  ggplot(aes(DAS,value,color=DFG_year))+\n  geom_line()+\n  facet_grid(~Terms)+\n  theme_test()+\n  theme(strip.background = element_blank(),\n        strip.text = element_text(size=14),\n        axis.text = element_text(size=14),\n        axis.title = element_text(size=14),\n        legend.position = c(.1,.1))+\n  scale_y_log10(\n    labels = label_number(scale_cut = cut_short_scale())\n  )+\n  xlab('Days after sowing')\n```\n\n::: {.cell-output-display}\n![long format and facet](index_files/figure-html/fig-facet-1.png){#fig-facet width=1152}\n:::\n:::\n\n\n::: callout-warning\n## challenge\n\nAnalyze the code that generating Fig2.\n\nFigure out how it works by blocking one line at a time. add documentation for each line.\n\nWhich function need package `scales`?\n:::\n\n### long ↔ wide\n\nTheoretically, we can easzily switch between the forms. Are they really the same after transforming back?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# long\nclimate_long <- climate %>% # climate is wide\n  tidyr::pivot_longer(names_to = \"Daily_Terms\",\n                      values_to = \"Daily_value\",\n                      cols = contains(\"Daily\")) \n# wide again\nclimate_wide<- climate_long%>% \n  tidyr::pivot_wider(names_from = \"Daily_Terms\",\n                     values_from = \"Daily_value\")\n\n# check if they are the same \nsetdiff(names(climate),names(climate_wide))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\ncharacter(0)\n```\n\n\n:::\n\n```{.r .cell-code}\nall.equal(climate,climate_wide)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n [1] \"Names: 8 string mismatches\"                                                            \n [2] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n [3] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n [4] \"Component 5: Mean relative difference: 96.42546\"                                       \n [5] \"Component 6: Mean relative difference: 0.8220306\"                                      \n [6] \"Component 7: Mean relative difference: 1534.907\"                                       \n [7] \"Component 8: Modes: numeric, character\"                                                \n [8] \"Component 8: target is numeric, current is character\"                                  \n [9] \"Component 9: Modes: numeric, character\"                                                \n[10] \"Component 9: target is numeric, current is character\"                                  \n[11] \"Component 10: Mean relative difference: 0.9968243\"                                     \n[12] \"Component 11: Modes: character, numeric\"                                               \n[13] \"Component 11: target is character, current is numeric\"                                 \n[14] \"Component 12: Modes: character, numeric\"                                               \n[15] \"Component 12: target is character, current is numeric\"                                 \n```\n\n\n:::\n\n```{.r .cell-code}\n# change the order of column\nall.equal(climate,climate_wide[,names(climate)])\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] \"Attributes: < Component \\\"class\\\": Lengths (1, 3) differ (string compare on first 1) >\"\n[2] \"Attributes: < Component \\\"class\\\": 1 string mismatch >\"                                \n```\n\n\n:::\n\n```{.r .cell-code}\n# change the type\nall.equal(climate,climate_wide[,names(climate)]%>% as.data.frame())\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] TRUE\n```\n\n\n:::\n:::\n\n\n::: callout-warning\n## Discussion\n\n`wide` refers to one column one trait and `long` denotes the stacked traits in two columns (names and values).\n\n1.  From `select` and `filter` point of view, when is `wide` format useful and when is `long` ideal?\n\n2.  If you want to `mutate` a column based on calculation between multiple traits, e.g., `DailyMean_Temperature`-`DailySum_Percipitation`/`DailySum_Radiation`, then which format is more suitable? or is it both possible?\n:::\n\n<!-- ### Protocols of making a regression plot -->\n\n<!-- [![Click to read original article](Protocol.jpg)](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.12577) -->\n\n## Looping with for(), lapply() and map()\n\ndeal repetitive tasks with loops.[^2]\n\n[^2]: [lapply vs for loop](https://nicercode.github.io/guides/repeating-things/)\n\n[lapply vs purrr](https://stackoverflow.com/questions/45101045/why-use-purrrmap-instead-of-lapply)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfilename <- c('grain_counting_practice_studentName1.xlsx',\n              'grain_counting_practice_studentName2.xlsx')\nfile_list<- filename %>% strsplit(\"_\")\n# tradition way of for loop\nres <- c()\nfor(i in 1:2){\n  res <- c(res,file_list[[i]][4])\n}\n\n# alternative in r package purrr\n# chr stands for the \"character\" output.\npurrr::map_chr(1:length(file_list),  ~{\n  file_list[[.x]][4]\n})\n\n# notice that the output of map_chr must be 1 element per iteration.\npurrr::map_chr(filename,  ~{\n  .x %>% strsplit(\"_\") %>% unlist()\n})\n\n# equivalent\npurrr::map(filename,  ~{\n  .x %>% strsplit(\"_\") %>% unlist()\n})\n\nlapply(filename,function(x){\n  x %>% strsplit(\"_\") %>% unlist()\n})\n```\n:::\n\n\n### read your own data\n\nGo to [HU-box](https://box.hu-berlin.de/d/fc7db144021a4a35a086/), download the `student` folder.\n\n::: callout-note\n## challenge\n\nusing for loop, extract the student name from file name.\n1. list the files of the folder `student` using `list.files()` \n2. write your own for loop.\n![](forloop.png)\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nnamed list()\n```\n\n\n:::\n:::\n\n:::\n\n## recommendation\n\n[purrr](https://www.rebeccabarter.com/blog/2019-08-19_purrr)\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}