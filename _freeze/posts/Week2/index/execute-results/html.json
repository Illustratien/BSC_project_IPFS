{
  "hash": "4ad19a9f047c6794dacb414679fa2374",
  "result": {
    "markdown": "---\ntitle: \"Week2: Working directory and accessor\"\nauthor: \"Tien-Cheng\"\ncategories: [vector,working directory]\nimage: 'vectors.png'\ntoc-location: right\nwebsite: \n  sidebar:\n    search: true\nnumber-sections: true\nformat:\n  html: \n    html-math-method: katex\nreference-location: margin\n---\n\n\n\n\nWelcome to the second course! You will learn `working directory`, subset elements from `vector`, `list` and `dataframe`.\n\n::: callout-note\n1. data type `logical` and `operator`\n2. accessor `[]`\n3. What is working directory (wd)?\n4.  How to access elements from `vector`, `list` and `dataframe`\n:::\n\n\n# Conditions: logical operators and vectors\n![Logical vector](logical.png)\nLogical operators [^1]\n\n[^1]:[logical operators](https://www.statmethods.net/management/operators.html)\n\n* `L==R`: direction doesn't matters.\n* `L%in%R`: one sided, check if object `L` is presence in `R`.\n* `!`: negate the logical vector.\n\n::: {.cell}\n\n```{.r .cell-code}\n# check if pattern exist in vector\n3%in%c(1,3)\n# what is the difference?\nc(1,3)%in%3\n2%in%c(1,3) \n1==2 \n1==c(2,1) \n# elementwise check whether L equals\nc(2,1)==1\n# check identity pairwise\nc(1,2)==c(2,4)\n# is '!' reverse the logical vector?\n!1==2 \n1!=2 \nc(1,3)==2\n# what does which() returns?\nwhich(c(1,3)==3) \n# what will be the data type? check with str()\nc(1,2,NA) %>% is.na() \nc(1,2,NA) %>% is.na() %>% which() \nc(1,2,NA) %>% is.na() %>% !.\nc(1,2,NA) %>% !is.na() \n!is.na(c(1,2,NA))\n```\n:::\n\n\nPreconditions examples inside a function\n\n::: {.cell}\n\n```{.r .cell-code}\n# check if data type match\narg <- \"\"\nis.character(arg)\nif(is.character(arg)){\n  print(\"character\")\n}\nif(is.character(arg)){\n  print(\"character\")\n}else{\n  error(\"type other than character\")\n}\nif(is.character(arg)){\n  warning(\"wrong\")\n}\nif(is.character(arg)){\n  stop(\"wrong\")\n}\n```\n:::\n\n::: {.callout-tip }\n# challenge\nInside your `plusone` function, please check first whether input `x` is numeric, then proceed the process.\nif not, return with message \"wrong input type\" using `stop()`\n:::\n\n# Working directory\n\n## preparation\n\n1.  Open the folder that contain `Wheat_BSC_project.Rproj`\n2.  download the data from [HU-box](https://box.hu-berlin.de/d/fc7db144021a4a35a086/), save it in `data`.\n3.  create Week2.R and save it in folder `src`.\n\n!['folder structure'](folder.PNG){width=400}\n\nWhat is working directory (wd)?\n\n## abbreviation path: \".\" for wd and \"..\" for parent of wd\n\n`\".\"` means the working directory (wd) where this R script exists.\n\n`\"..\"` means the parent (one level higher) directory of `\".\"`.\n\n::: {.callout-tip collapse=\"true\"}\n# click for example\n![](wdirectory.png)\n:::\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dplyr)\n\n# working directory, abbreviated as \".\"\ngetwd()\n# parent directory, abbreviated as \"..\"\ndirname(getwd())\n# assign current path to variable\ncurrent_path <- getwd()\n# check the type \ncurrent_path %>% str()\n\n\n# check files in the directory\n\n# are they different?\n\".\" %>% list.files(path=.)\ngetwd() %>% list.files(path=.)\n\n# are they different?\n\"..\" %>% list.files(path=.)\ngetwd() %>% dirname() %>% list.files(path=.)\n```\n:::\n\n\n::: {.callout-tip }\n# challenge\nAlthough the meaning of `.` is the same as `getwd()`, the content is depending on the environment you are working with.\n\nRight click R studio logo, open a new R studio window, compare the result of `getwd()` in R project and R\n:::\n\n## accessing files and folder inside a R project\n\nWhich one do you prefer? Why do we prefer relative path?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# absolute path, did you get error?\n\"C:/Users/marse/seadrive_root/Tien-Che/My Libraries/PhD_Tien/Project/Postdoc_teaching/BSC_project_IPFS2023/data\" %>% list.files(path=.)\n# relative path in R base\nparent_path <- getwd() \npaste0(parent_path,\"/data\") %>% list.files(path=.)\n\n# Does this works? \n\".\\data\" %>% list.files(path=.)\n\"data\" %>% list.files(path=.)\n```\n:::\n\n\n::: {.callout-tip collapse=\"true\"}\n# click for example\n\n|   symbol  |  Absolute path  | relative path   |color|\n|:---:|:-----------------:|:------------------:|:------------------:|\n| A    |    `C/users/Wheat_BSC_project`    |   `..`    | black|\n| B   | `C/users/Wheat_BSC_project/data` |?|blue|\n| C    |  `C/users/Wheat_BSC_project/src`   |   `.`    |red|\n| D    |  `C/users/Wheat_BSC_project/src/data`  |   ?   |blue|\n\n\n\nBelow are four relative paths. Please rewrite them in absolute (full) path form. \nWhich two are the same? Based on the figure illustated below, path 1-4 should be A,B,C or D?\n\n1.  `\"ear_summarized.csv\"`\n\n2.  `\"data/ear_summarized.csv\"`\n\n3.  `\"./data/ear_summarized.csv\"`\n\n4.  `\"../data/ear_summarized.csv\"`\n\n![](wd.PNG){width=\"800,height\"}\n:::\n\n# get element from a vetor with `accessors []`\n![accessor](accessor.PNG){width=400}\n\nvector indexing start from 1 to the length of the vector.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nempty_vec <- c()\nlength(empty_vec)\n# what is the type of the empty vec?\nempty_vec %>% str()\n\n# NULL: empty \nempty_vec[1]\nempty_vec[0]\n\n\nvec <- c(1,3,5)\nvec[1]\n#reorder the vector \nvec[c(2,1,3)]\n```\n:::\n\n\n![](order.PNG){width=400}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# removing the indexed elements\nvec[-1]\nvec[-2]\n\n# indexing start from 1, not 0\n# therefore you get, numeric(0)\nvec[0]\n# when access exceeding the range of a vector, what datatype do you get? \nvec[4]\nvec %>% .[length(.)+1]\nvec[1:4]\nvec[4:1]\n\n# find specific element or position\nvec[c(F,T,F)]\nvec[vec==5]\n# when codition not match at all, it will return? \nvec[vec==2]\nvec[c(F,F,F)]\nvec %>% .[c(F)]\nvec[vec==\"a\"]\n\n# default str vector\nletters\nLETTERS\n# when the query does not match, guess what will be the datatype? \nletters %>% .[.==2]\nletters %>% .[c(F)]\n# vector over write\nvec\nvec <- c(2,1,3)\nvec\n```\n:::\n\n\n::: {.callout-tip }\n# challenge\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1, 2, 3, 4, 5)\nlogical_vec <- c(TRUE, FALSE)\nsubset_vec <- vec[logical_vec]\nsubset_vec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 3 5\n```\n:::\n:::\n\n\nwhat did you observe? Is there any [vector recycling](https://rpubs.com/vipero7/vector-recycling-in-r)?\n\nWhat happen when you enter `vec[TRUE]`?\n:::\n\nSupplementary information of special datatypes:[^2]\n\n[^2]: Data type emplty: [NULL](https://www.r-bloggers.com/2018/07/r-null-values-null-na-nan-inf/)\\nIndexing at zero position: [numeric(0)](https://www.programmingr.com/r-error-messages/numeric0-error/)\n\n# list: keep the diversity of data type\n\nMake a list is like put a `cookie`(content of list element) in the `cookie jar`(list element).\n\n::: {.cell}\n\n```{.r .cell-code}\n# list without element name\nlist_a <- list(c(1,2))\n```\n:::\n\n\n![list without name](list_example.png){width=\"800,height\"}\nThere are 3 common accessors for `list`:\n\n1. access the list element (`cookie jar`)\n* `[]` access the list position\n\n2.  access the content of list element (`all cookies in jar`)\n* `[[]]` access the content of a list element by position  or name\n\n3. access the *specific* content of list element (`selected cookie(s)`)\n\n* `[[]][]`, position of logical vector\n\n\n\n\n::: {.callout-tip collapse=\"true\"}\n# click for example\n\n::: {.cell}\n\n```{.r .cell-code}\nvec_obj <- c(1,2,4,5)\n# position vector\npos_vec <- c(2,3,1)\nlist_obj <- list(vec_obj)\n# element id\nele_ind <- 1\n```\n:::\n\n\n|action  |vector|list|\n|:--------:|:-----------:|:------------------:|\n| extract from content| `vec_obj[pos_vec]`|  `list_obj[[ele_ind]][pos_vec]`|\n|refer to content (data type:list)|`vec_obj`|`list_obj[[ele_ind]]`|\n|refer to position (data type:list) | |`list_obj[ele_ind]`|\n\n* `pos_vec` or `ele_ind` could also be either numeric or logical\n:::\n\n## access content by name\n`$` access the content of a list element by name\nlist_object`$element_name` or list_object`[[element_name]]`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# list without element name\nlist_b <- list(nam=c(1,2))\n```\n:::\n\n![list with name](list_example2.png){width=\"800,height\"}\n\nMore about the accessors. [^1]\n\n[^1]: [accessors](https://www.r-bloggers.com/2009/10/r-accessors-explained/)\n\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a simple list\nlist(1)\n# create a simple list with name \"x\" for first element\nlist(x=1)\nlist(x=1)[\"x\"]\n# extract content\nlist(x=1)$\"x\"\nlist(x=1)[[1]]\nlist(x=1)[[\"x\"]]\n\n# extract with pipe\nlist(x=1) %>% .[[1]]\nlist(x=1) %>% .$\"x\"\n\n# long list\nlong_list_example <- list(1,c(1,2),\n                          T,c(T,T),\n                          \"str\",c(\"a\",\"b\"),\n                          list(1),\n                          mean,data.frame())\n# check the content\nlong_list_example\n# check structure of this list \n# list_complex_example %>% str()\n# list_complex_example %>% glimpse()\n# list_complex_example\n# first list \nlong_list_example[1]\n# content of first list\nlong_list_example[[1]]\n# first element of content of first list\nlong_list_example[[1]][1]\n```\n:::\n\n\n::: {.callout-tip }\n# challenge\ncan you guess what data type are these?\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# non-sense\nlong_list_example[[1]][2]\nlong_list_example[1][1]\nlong_list_example[1][2]\nlong_list_example[2][2]\n# meaningful\nlong_list_example[[2]][2]\n```\n:::\n\n:::\n\n## lapply: apply functions and return `list`\n\nlapply(vector, function) ?lapply\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# input is vector\nc(1,4) %>% \n  lapply(.,FUN=function(x){x+3})\n# input is list\nlist(2,4,c(1,4)) %>% \n  lapply(.,FUN=function(x){x+3})\n# input has differnt type\nlist(2,4,c(1,4),\"8\") %>% \n  lapply(.,FUN=function(x){x+3})\n```\n:::\n\n\n::: {.callout-tip }\n# challenge\nWhy you get error in the last line?\n:::\n\n# dataframe is a special type of list\n\neach column has one data type\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# create a dataframe \ndf <- data.frame(time=as.Date(\"2023-04-16\",format=\"%Y-%m-%d\")+seq(1,3,1),\\temp=c(20,15,13),\\thermal_time=cumsum(c(20,15,13)))\n# another way\ndf <- data.frame(time=as.Date(\"2023-04-16\",format=\"%Y-%m-%d\")+seq(1,3,1)) \ndf$temp=c(20,15,13)\ndf$thermal_time=cumsum(df$temp)\n\n# third method\nlibrary(dplyr)\ndf <- data.frame(time=as.Date(\"2023-04-16\",format=\"%Y-%m-%d\")+seq(1,3,1)) %>% \n  mutate(temp=c(20,15,13), \n         thermal_time=cumsum(temp))\ndf\n```\n:::\n\n\n::: {.callout-tip }\n# challenge\nIs it possible to create data frame with vectors of different length?\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndata.frame(time=as.Date(\"2023-04-16\",format=\"%Y-%m-%d\")+seq(1,3,1), \n           temp=c(20,13))\n```\n:::\n\n:::\n\n## extract columns from data frame\n\nYou can subset `dataframe` by indexing \\[`row`,`column`\\]\n\n`dataframe`\\[,`column`\\] select the whole role for selected columnn\n\n`dataframe`\\[`row`,\\] select the whole column of selected rows\n\nSelect multiple row or column by puting logical or numeric vector in the square bracket.\n\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip }\n# challenge\nuse `df`,\n\n1.  Access column `thermal_time` as `vector`\n\n2.  Extract `temp` when `time` is `2023-04-17`\n\n3.  Extract first row and first column with `[1,]`and `[,1]`\n:::\n\n::: callout-challenge\nif you want to turn a data frame (`df`) by 90 degree (\"transpose\"), which function can you use? Could you find the answer on google or chatGPT?\n:::\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}